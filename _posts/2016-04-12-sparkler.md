---
layout: post
title:  "Sparkler"
date:   2016-04-12 22:13:39
categories: java
---

I recently started a project in which I need to build several RESTful API's and microservices in Java. I wanted to find or build a framework, or at least a reference application. At the end of the day, I wanted an API with a dead simple domain just to show what it would take to build something deployable in a real-world way. When I started scoping out the architecture, I thought about the fact that the last Java REST API I'd built from scratch was in 2012. I'd developed a few in Rails and Sinatra-based API's in the meantime, though, and I wanted a similar developer experience in Java.

Allow me to introduce you to [Sparkler](https://github.com/saslani/sparkler)! Sparkler was developed by two software engineers, Sarah Aslanifar (myself) and [Bobby Norton](http://bobbynorton.com/), as a way for us to show people a working example of the design principles we wanted when building Java web applications. You can check out the README for details about how to get started, but this article is an introduction about why we built it along with some of the design principles and values we employed.


#### The Server and REST API: Spark Framework
Not to be confused with the distributed computing framework Apache Spark, this is the relatively new Java Web Application "microframework". Based on the design principles of Sinatra and leveraging the functional programming potential of Java 8, Spark proved to be a fantastic foundation for the stack I wanted to build. After spending a couple of hours experimenting with one of Frederico Tomassetti's [well-written tutorial](https://sparktutorials.github.io/2015/04/03/spark-lombok-jackson-reduce-boilerplate.html), I was ready to extend Spark with my own ideas.

#### Guiding Principle: Deploy the application *with* a server, not deploy the application *into* a server

#### Functional Testing...with JUnit!

#### Support for polyglot persistence
Starting with RDBMS, but could be extended to any persistence store. The key was allowing for evolutionary schemas, automated migrations, and the ability to run something like H2 in development with Postgres in other environments.

Sql2o (hat tip again to the Spark tutorials)

Migrations: FlywayDB

#### Ready for Continuous Delivery

#### Developer Happiness

#### Is this a framework?

#### The Alternatives
It's worth mentioning, only briefly as a footnote, a few common approaches to building Java applications that were immediately discarded from further consideration. I won't list all alternatives I came across. The web is full of cats and "Hello World" tutorials for Java REST API's that show you the basics, but leave you hanging when it comes time to create a production-ready deployment. The principles these IDE-centric and WAR-torn tutorials employ are often irrelevant, at times contradictory to the ones described in this article.

Spring / Spring MVC: I have generally avoided the Spring ecosystem for the past few years. What started off with good intentions has become a grand complication. The [Spring Framework Reference Documentation](http://docs.spring.io/autorepo/docs/spring/3.2.x/spring-framework-reference/htmlsingle/) is 626 printed pages at the time of this writing.

The opening line of the overview states, "The Spring Framework is a lightweight solution and a potential one-stop-shop for building your enterprise-ready applications." Sorry, but "lightweight" and "one-stop-shop" don't sound like compatible goals to me. I'm looking for a solution that follows the [Unix Philosophy](http://www.catb.org/esr/writings/taoup/html/ch01s06.html). I don't know about you, but simplicity and parsimony are words I don't often hear from myself or others when speaking of Spring.

WARs: I don't want the overhead of having to compile, deploy a WAR, and wait for an application server to launch an app before I see results. If I redeploy the application 20 times a day, waiting a minute or two for each iteration means I could lose almost an hour.

A workflow that depends on an IDE: If the work can't be automated on a command line, you've locked yourself and your team into an exercise of point and click in Eclipse or IntelliJ. It's doesn't scale, and it's not fun.