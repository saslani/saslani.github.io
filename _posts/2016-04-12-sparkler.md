---
layout: post
title:  "Sparkler"
date:   2016-04-12 22:13:39
categories: java
---

I recently started a project in which I need to build several RESTful API's and microservices in Java. I wanted to find or build a framework, or at least a reference application. At the end of the day, I wanted an API with a dead simple domain just to show what it would take to build something deployable in a real-world way. When I started scoping out the architecture, I thought about the fact that the last Java REST API I'd built from scratch was in 2012. I'd developed a few in Rails and Sinatra-based API's in the meantime, though, and I wanted a similar developer experience in Java.

Allow me to introduce you to [Sparkler](https://github.com/saslani/sparkler)! Sparkler was developed by two software engineers, Sarah Aslanifar (myself) and [Bobby Norton](http://bobbynorton.com/), as a way for us to show people a working example of the design principles we wanted when building Java web applications. You can check out the README for details about how to get started, but this article is an introduction about why we built it along with some of the design principles and values we employed.


#### The Server and REST API: Spark Framework
Not to be confused with the distributed computing framework Apache Spark, this is the relatively new Java Web Application "microframework". Based on the design principles of Sinatra and leveraging the functional programming potential of Java 8, Spark proved to be a fantastic foundation for the stack I wanted to build. After spending a couple of hours experimenting with one of Frederico Tomassetti's [well-written tutorial](https://sparktutorials.github.io/2015/04/03/spark-lombok-jackson-reduce-boilerplate.html), I was ready to extend Spark with my own ideas.

#### Guiding Principle: Deploy the application *with* a server, not deploy the application *into* a server

#### Functional Testing...with JUnit!

#### Support for polyglot persistence
Starting with RDBMS, but could be extended to any persistence store. The key was allowing for evolutionary schemas, automated migrations, and the ability to run something like H2 in development with Postgres in other environments.

Sql2o (hat tip again to the Spark tutorials)

Migrations: FlywayDB

#### Ready for Continuous Delivery

Sparkler folows the [12 factor app](http://12factor.net/), most importantly when it comes to **_Config_** and **_Build, release, run_**:

* III. Config: Sparkler keeps the configuration seperate form the code by enabling the application to read them from environment variables rather than a config file.

	> A litmus test for whether an app has all config correctly factored out of the code is whether the codebase could be made open source at any moment, without compromising any credentials.

* V. Build, release, run: it easy to release the artifact everywhere when you have a tarball:

```
make heroku-deploy
```

Heroku as a way to quickly get started. Putting 12 Factor App to the test.

```
make heroku-deploy
```

#### Semantic Versioning
Sparkler is following the SemVer idea of defining the public interface explicitly.

#### Developer Happiness

#### Is this a framework?
Maybe some day. A framework implies a level of extensibility through the open-closed principle that is currently missing in Sparkler. It's not closed at all, in fact. It's completely open for you to inspect, criticize, and most importantly, understand. As such, it's a reference application for me and other developers with like-minded design principles to easily build Java-based REST API's. On one hand, there's nothing new here. On the other, we couldn't find any other project where all of these ideas had been combined.

Maybe you don't agree with some of the choices we made. Maybe you think configuration files should be used in favor of environment variables, or perhaps you like Ant instead of Maven. That's the beauty of open source: You're welcome to fork Sparkler and modify it in any way you wish.

If there's ever sufficient need after we've deployed several production applications based on Sparkler, it might be time to think about introducing a framework. For now, I think the value is in seeing how Java is a viable alternative for iterative, adaptive REST API development. I think there are some interesting design alternatives in Sparkler for the SparkJava community to consider.

The next article I'm planning for Sparkler is for something I wish more applications had...a simple way to record usage of an application.

In addition to a write-up for how to build a more complicated domain in Sparkler, some follow-up articles might be in order for the functional testing approach, support for different databases in dev and prod-like environments, or the release approach. I'd love to hear from you on Twitter @saslani or by email: sarah@testedminds.com.

So let's get you started with Sparkler:

* clone or download [sparkler](https://github.com/saslani/sparkler) in your local environment
* make test
* make server
* now all you need to do is to put time and focus on build your business idea!

To deploy to heroku or create a tarball please refer to the [README](https://github.com/saslani/sparkler/blob/master/README.md)

#### The Alternatives
It's worth mentioning, only briefly as a footnote, a few common approaches to building Java applications that were immediately discarded from further consideration. I won't list all alternatives I came across. The web is full of cats and "Hello World" tutorials for Java REST API's that show you the basics, but leave you hanging when it comes time to create a production-ready deployment. The principles these IDE-centric and WAR-torn tutorials employ are often irrelevant, at times contradictory to the ones described in this article.

Spring / Spring MVC: I have generally avoided the Spring ecosystem for the past few years. What started off with good intentions has become a grand complication. The [Spring Framework Reference Documentation](http://docs.spring.io/autorepo/docs/spring/3.2.x/spring-framework-reference/htmlsingle/) is 626 printed pages at the time of this writing.

The opening line of the overview states, "The Spring Framework is a lightweight solution and a potential one-stop-shop for building your enterprise-ready applications." Sorry, but "lightweight" and "one-stop-shop" don't sound like compatible goals to me. I'm looking for a solution that follows the [Unix Philosophy](http://www.catb.org/esr/writings/taoup/html/ch01s06.html). I don't know about you, but simplicity and parsimony are words I don't often hear from myself or others when speaking of Spring.

WARs: I don't want the overhead of having to compile, deploy a WAR, and wait for an application server to launch an app before I see results. If I redeploy the application 20 times a day, waiting a minute or two for each iteration means I could lose almost an hour.

A workflow that depends on an IDE: If the work can't be automated on a command line, you've locked yourself and your team into an exercise of point and click in Eclipse or IntelliJ. It's doesn't scale, and it's not fun.
